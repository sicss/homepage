<!DOCTYPE html>

<html lang="en">

  <head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="msapplication-tap-highlight" content="no">

  
    <meta name="description" content="">
  

  <title>Logics 2016 Lecture Notes Five (Part II: 1-3) - Sicss Society</title>

  <link href="/projects/logics-2016/lecture-notes/css/main.css" rel="stylesheet" type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/table.css" rel="stylesheet" type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/list.css" rel="stylesheet" type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/common.css" rel="stylesheet" type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/header.css" rel="stylesheet"  type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/footer.css" rel="stylesheet"  type="text/css"/>

  

  

  
  
      <link rel="stylesheet" href="/projects/logics-2016/lecture-notes/css/adoc.css" type="text/css">
      <link rel="stylesheet" href="/projects/logics-2016/lecture-notes/css/coderay.css" type="text/css">
  

  
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$']], displayMath: [['$-$', '$-$']]},
  TeX: { equationNumbers: {autoNumber: "AMS"} }
});

// to fix headaches caused by Hyphenator.js
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  MathJax.InputJax.TeX.prefilterHooks.Add(function (data) {
    data.math = data.math.replace(/\u00AD/g,"");
  });
});
    </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG" type="text/javascript"></script>
  

    <script src="/projects/logics-2016/lecture-notes/js/cjk-newline-remover.js" type="text/javascript"></script>
    <script type="text/javascript">
document.addEventListener("DOMContentLoaded", function() {
  CjkNewlineRemover.processParagraphs()
});
    </script>

</head>



  <body>

    



    <main>
      <link href="/projects/logics-2016/lecture-notes/css/article_base.css" rel="stylesheet" type="text/css"/>
<script src="/projects/logics-2016/lecture-notes/js/hyphenate.js" type="text/javascript"></script>

<script type="text/javascript">
  document.addEventListener('DOMContentLoaded', function(){
    document.querySelectorAll(".article").forEach(function(elem){elem.classList.add("hyphenate")});
    document.querySelectorAll("div.title").forEach(function(elem){elem.classList.add("donthyphenate")});
    Hyphenator.run();
  });
</script>

<article class="article">

  <header class="article-header">

  <div class="page-navigation">
    <ul>
      <!-- <li id="page-navigation-previous"><span><a href="">Previous</a></span></li> -->
      <li id="page-navigation-home"><span><a href="/projects/logics-2016/lecture-notes/">Contents</a></span></li>
      <!-- <li id="page-navigation-next"><span><a href="">Next</a></span></li> -->
    </ul>
  </div>

  <h1 class="article-title">Logics 2016 Lecture Notes Five (Part II: 1-3)</h1>

  <p class="article-meta">
    
      <time datetime="2016-11-12T00:00:00+09:00" itemprop="datePublished">November, 2016</time>

      <br/>

      

      <span class="referral">

	
	<span class="revision">Version One, Second Draft, First Revision</span>
	

	<span class="repo-ref">logics-2016/lecture-notes:git-a2541588159d940d4c536b33596682ed6684ad56</span>
	<span class="url-ref"><a href="http://sicss.org/projects/logics-2016/lecture-notes/Logics-2016-Lecture-Notes-Five">http://sicss.org/projects/logics-2016/lecture-notes/Logics-2016-Lecture-Notes-Five</a></span>
      </span>


  </p>

</header>

<div class="article-content">
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph preface">
<div class="title">Preamble</div>
<p>This article is part of the lecture notes series authored for Sicss Logics Seminar 2016. This
article covers Part II: <strong>1. General Introduction: Predicate Logic</strong> to <strong>3. Variables</strong>. This note
is unfinished.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-1-general-introduction-predicate-logic">Chapter 1. General Introduction: Predicate Logic</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(More to be added)</p>
</div>
<div class="paragraph">
<p><strong>First order logic</strong> is not one particular formal system. It is, instead, a class of formal systems
that share a specific scheme for their syntax, semantics, and proof theory, so that <em>logical facts</em>
demonstrated in one such formal system will unconditionally hold in another formal system in this
class. A particular instance of the class of first order theory is called a <strong>First Order Theory</strong>,
or, if there is no ambiguity, a <strong>Theory</strong>.</p>
</div>
<div class="paragraph">
<p>Even though in the previous paragraph it is stated that first order theories share one specific
scheme for syntax, semantics, and proof theory, different authors usually introduce different such
scheme. In fact, there are multiple such scheme that are equivalent to each other. Although the
choices of syntax are usually almost the same, the choices of semantics, and especially proof theory
may be tremendously different. But nevertheless, since those schemes are equivalent, the classes of
formal systems following such schemes are all called first order logic. We are going to fix a
particular such scheme (and thus a particular class of formal systems) that we are going to study
very closely in this seminar, and we will refer to this scheme as <strong>Pred<sup>1</sup></strong> throughout the coming
chapters and parts in the lecture notes.</p>
</div>
<div class="paragraph">
<p>(More to be added)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-2-syntax-of-em-pred-sup-1-sup-em-first-order-logic">Chapter 2. Syntax of <em>Pred<sup>1</sup></em> (First Order Logic)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Starting from Chapter 2 (this chapter!), a <strong>First Order Theory</strong> will be referred simply as <strong>Theory</strong>.</p>
</div>
<div class="paragraph">
<p>As stated, first class logic is a class of formal systems instead of just one. And thus different
instances in this class, i.e. different theory, are not the same. The first thing one has to choose
to specify a particular theory is the set of <strong>Function Symbols</strong> and the set of <strong>Predicate Symbols</strong>.
For example, if we are building a theory for number theory, we may want a function symbol for
addition, another function symbol for multiplication, etc; we may also want predicate symbols for
oddity, evenness, primality, etc. Different theories for different purpose usually have different
sets of function symbols and predicate symbols. In order to introduce the syntax of <strong>Pred<sup>1</sup></strong>, which
is actually a <em>scheme</em> for syntax parameterized with the choice of the sets of function symbol and
predicate symbol, we are not going to fix those set. Instead, we are going to refer to those sets
abstractly as $\mathfrak{F}$ or $\mathfrak{P}$, respectively for the set of function symbols or
predicate symbols.</p>
</div>
<div class="paragraph">
<p>Usually in math, a function or a predicate may take one or more arguments, but the number of
arguments is fixed for a specific function or predicate. Such number for a function or predicate is
called the <strong>arity</strong> of this function or predicate. A function or predicate with an arity of k is
usually called a <em>k-degree function/predicate</em>. This is the same for function and predicate symbols
in <strong>Pred<sup>1</sup></strong>, and actually the same in most styles of first order logic. So we will refer to a
function or predicate symbol with an arity of k a <em>k-degree function/predicate symbol</em>. We will also
refer to the subset of $\mathfrak{F}$ whose elements have an arity of k as $\mathfrak{F}_k$, and do
the same for $\mathfrak{P}_k$. Finally, a <strong>constant</strong> in a theory, whose sole duty is to denote a
single object (such as the number 5 in number theory), is an element in $\mathfrak{F}_0$, i.e. a
function symbol with an arity of 0.</p>
</div>
<div class="paragraph">
<p>The (abstract) syntax of <strong>Pred<sup>1</sup></strong> (more precisely, a theory in the class of <strong>Pred<sup>1</sup></strong> with the set
of function symbols being $\mathfrak{F}$ and the set of predicate symbols being $\mathfrak{P}$) is
then given by the following BNFs.</p>
</div>
<div class="paragraph">
<p>$-$
\newcommand\bnfalt{\;|\;}
\newcommand\nat{\mathbb{N}}
\newcommand\fentails{\rightarrow}
\newcommand\fand\wedge
\newcommand\for\vee
\newcommand\funivq\forall
\newcommand\fexq\exists
\newcommand\bnfhd[2]{\mathbf{#1}\;\;\ni\;\;#2\;\;::=\;\;}
\begin{align*}
  \bnfhd{Var}{x} &amp; x_i \quad \text{(for $i \in \nat$)} \\
  \bnfhd{Term}{t} &amp;
    x \bnfalt
    f(t_1, \dots, t_k) \quad \text{(for $f \in \mathfrak{F}_k$, a k-degree function symbol)} \\
  \bnfhd{Form}{\phi} &amp;
    \bot \bnfalt t = t \bnfalt
    P(t_1, \dots, t_k) \quad \text{(for $P \in \mathfrak{P}_k$, a k-degree predicate symbol)} \\ &amp; \bnfalt
    \phi \fand \phi \bnfalt \phi \for \phi \bnfalt
    \phi \fentails \phi \\ &amp; \bnfalt
    \funivq x \phi \bnfalt \fexq x \phi
\end{align*}
$-$</p>
</div>
<div class="paragraph">
<p>(maybe more discussion to be added)</p>
</div>
<div class="paragraph">
<p><strong>Exercise 1:</strong> convert all the three BNFs above to <em>inference rules</em> style of inductive definitions,
and write down the induction principle for them.</p>
</div>
<div class="paragraph">
<p><strong>Exercise 2:</strong> define functions $\text{size} : \mathbf{Form} \rightarrow \nat$ and $\text{depth} :
\mathbf{Form} \rightarrow \nat$ in the suitable sense for formulas in <strong>Pred<sup>1</sup></strong>, and prove the
property: <em>for any formula, its depth is less or equal to its size</em>. Hint: use the induction
principle for $\mathbf{Form}$, or structural induction on terms directly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-3-variables">Chapter 3. Variables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Note that in the last two clauses of the BNF for $\mathbf{Form}$, namely $\funivq x \phi$ and $\fexq
x \phi$, there are occurrences of <strong>variables</strong>, namely the $x$'s. Variables in mathematics appears
basically everywhere, such as in functions, in propositions, etc. and are also handled intuitively.
For example to apply 5 to the function $\lambda x. (x - 3)(x^2 + 2)$, we firstly replace all $x$'s
in the body of the function to get $(5 - 3) (5^2 + 2)$ then perform ordinary arithmetic to get the
final result, which is 54 in this case. Since variable is nowadays a standard device taught from
elementary school level math classes, intuitive handling is usually sufficient in most cases.
However, in formal systems involving variables such as the first order logic, it must be very clear
(in the sense of mathematical preciseness) how variables are treated, which is the topic of this
chapter.</p>
</div>
<div class="paragraph">
<p>In this chapter, we are going to study the current de facto standard formal treatment for variables,
where "treatment" means the interpretation and manipulation of variables in a formal language. For
interpretation, we are going to introduce the concepts of <strong>scope</strong> and <strong>boundness</strong>, and for
manipulation, we are going to define the action of substituting a variable to something else in an
expression, which is usually referred to as <strong>variable substitution</strong>.</p>
</div>
<div class="sect2">
<h3 id="section-3-1-scope-boundness">Section 3.1. Scope &amp; Boundness</h3>
<div class="paragraph">
<p>One could easily see that, in the expression $ ( (\lambda x. x^2 + x + 1) (x + 2) ) + x $, the $x$'s
are not referring to the same thing. Since there are too many of them, let us number those
<strong>occurrences</strong> of $x$: $ ( (\lambda x_1. x_2^2 + x_3 + 1) (x_4 + 2) ) + x_5 $. Intuitively, we could
see that $x_1$, $x_2$, and $x_3$ are referring to the number, not yet known at this point though;
and $x_4$ and $x_5$ are referring to another number, also not yet known. If in a <strong>context</strong> where
$x = 5$, the expression indeed means $ ( (\lambda x. x^2 + x + 1) (5 + 2) ) + 5 $ which in turn
means $ ( (\lambda x. x^2 + x + 1) (7) ) + 5 $, which in turn means $ (7^2 + 7 + 1) + 5 $, which we
could calculate as usual and get 62 as the result. Here, obviously, those $x$'s with different
subscripts should not be understood as different variables as in usual occasions: they are all the
same variable $x$ and the subscripts are added only to indicate occurrences at specific positions.</p>
</div>
<div class="paragraph">
<p>Why in the previous example those two groups of occurrences of the same variable refer to two
different number is also evident to us: in the subexpression $ (\lambda x_1. x_2^2 + x_3 + 1) $, we
declare a new variable $x$, which governs the rest of the occurrences of $x$ in this subexpression
and separate them from those occurrences of $x$'s in the rest of the expression. In logics and
computer science, this action of "declaring" a new variable is called <strong>variable binding</strong>. The
occurrence $x_1$, the one indicating which variable the action is binding, is called the <strong>binding
occurrence</strong>. The occurrences $x_2$ and $x_3$ in the subexpression are then called <strong>bound
occurrences</strong>. The $\lambda$ here is called a <strong>binder</strong>, since it indicates that the variable
occurrence immediately following it is a binding occurrence. The effect of the action of variable
binding is always limited, as for in the previous example, $x_4$ and $x_5$ is not bound by $x_1$;
and the exact extension of such effect is called the <strong>scope</strong>. In the previous example, the <strong>scope</strong>
of the binding occurrence $x_1$ is exactly the subexpression $x_2^2 + x_3 + 1$; note that the binder
and the binding occurrence are not included in the scope.</p>
</div>
<div class="paragraph">
<p>We introduced binding and bound <em>occurrences</em> in the last paragraph, but those concepts are usually
too precise to be very useful. A coarser concept is the <strong>bound variables</strong>, which simply means the
variable, not the occurrence that is bound in a specific expression, i.e. it has binding (not
necessarily bound) occurrences in the expression. Taking this naming, we quite often abuse
terminologies and call an occurrence of some variable "bound" if it is either a binding occurrence
or a bound occurrence. In the opposite, we call an occurrence "free" if it is neither a binding
occurrence nor a bound occurrence. So in the previous example, $x_1, x_2, x_3$ are bound and $x_4,
x_5$ are free.</p>
</div>
<div class="paragraph">
<p>As bound variables, we also have a concept called <strong>free variable</strong>. A free variable in an expression
is a variable that has at least one occurrence in the expression, but all of those occurrences are
free. The concept of free variable is very important in the sense that the concept often occurs in
inductive definitions. We will later see that we require some variables to be free in inductive
definitions when specifying the proof theory of <strong>Pred<sup>1</sup></strong>. So let us formulate precisely what the
free variables are in a formula in the language of <strong>Pred<sup>1</sup></strong> as below.</p>
</div>
<div class="paragraph">
<p>$-$
\newcommand\pow[1]{\mathscr{P}(#1)}
\newcommand\null\varnothing
\newcommand\fvt{fv_t}
\newcommand\fvf{fv_\phi}
\begin{align*}
  \fvt : \mathbf{Term} &amp; \rightarrow \pow{\mathbf{Var}} \\
  \fvf : \mathbf{Form} &amp; \rightarrow \pow{\mathbf{Var}}
\end{align*}
$-$
$-$
\begin{align*}
  \fvt(x) &amp; = \{ x \} \\
  \fvt(f(t_1, \dots, t_k)) &amp; = \bigcup\limits_{i=1}^k \fvt (t_i) \\
  \fvf(\bot) &amp; = \null \\
  \fvf(t_1 = t_2) &amp; = \fvt(t_1) \cup \fvt(t_2) \\
  \fvf(P(t_1, \dots, t_k)) &amp; = \bigcup\limits_{i=1}^k \fvt (t_i) \\
  \fvf(\phi_1 \fand \phi_2) &amp; = \fvf(\phi_1) \cup \fvf(\phi_2) \\
  \fvf(\phi_1 \for \phi_2) &amp; = \fvf(\phi_1) \cup \fvf(\phi_2) \\
  \fvf(\phi_1 \fentails \phi_2) &amp; = \fvf(\phi_1) \cup \fvf(\phi_2) \\
  \fvf(\funivq x \phi) &amp; = \fvf(\phi) \setminus \{ x \} \\
  \fvf(\fexq x \phi) &amp; = \fvf(\phi) \setminus \{ x \}
\end{align*}
$-$</p>
</div>
<div class="paragraph">
<p>Since usually we know which one we mean by $fv(\dots)$, we usually abuse the notation and omit the
subscription $ _{t} $ or $ _{\phi} $.</p>
</div>
<div class="paragraph">
<p>(maybe add some examples)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-3-2-substitution">Section 3.2. Substitution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(to be added)</p>
</div>
</div>
</div>
</div>




</article>



    </main>

    <footer>

  <div class="hr"></div>

  <div class="copyright-notice">

    <p>
      Copyright &copy; 2016 Sicss Society. <br/>
      All rights reserved.
    </p>

    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> <br/>
      This work is licensed under a <br/>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
	Creative Commons Attribution-NonCommercial-ShareAlike 4.0
	International License</a>.
    </p>

  </div>

</footer>



  </body>

</html>

