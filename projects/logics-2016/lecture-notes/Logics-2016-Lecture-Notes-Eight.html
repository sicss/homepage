<!DOCTYPE html>

<html lang="en">

  <head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="msapplication-tap-highlight" content="no">

  
    <meta name="description" content="">
  

  <title>Logics 2016 Lecture Notes Eight (Part III: 1) - Sicss Society</title>

  <link href="/projects/logics-2016/lecture-notes/css/main.css" rel="stylesheet" type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/table.css" rel="stylesheet" type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/list.css" rel="stylesheet" type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/common.css" rel="stylesheet" type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/header.css" rel="stylesheet"  type="text/css"/>
  <link href="/projects/logics-2016/lecture-notes/css/footer.css" rel="stylesheet"  type="text/css"/>

  

  

  
  
      <link rel="stylesheet" href="/projects/logics-2016/lecture-notes/css/adoc.css" type="text/css">
      <link rel="stylesheet" href="/projects/logics-2016/lecture-notes/css/coderay.css" type="text/css">
  

  
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$']], displayMath: [['$-$', '$-$']]},
  TeX: { equationNumbers: {autoNumber: "AMS"} }
});

// to fix headaches caused by Hyphenator.js
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  MathJax.InputJax.TeX.prefilterHooks.Add(function (data) {
    data.math = data.math.replace(/\u00AD/g,"");
  });
});
    </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG" type="text/javascript"></script>
  

    <script src="/projects/logics-2016/lecture-notes/js/cjk-newline-remover.js" type="text/javascript"></script>
    <script type="text/javascript">
document.addEventListener("DOMContentLoaded", function() {
  CjkNewlineRemover.processParagraphs()
});
    </script>

</head>



  <body>

    



    <main>
      <link href="/projects/logics-2016/lecture-notes/css/article_base.css" rel="stylesheet" type="text/css"/>
<script src="/projects/logics-2016/lecture-notes/js/hyphenate.js" type="text/javascript"></script>

<script type="text/javascript">
  document.addEventListener('DOMContentLoaded', function(){
    document.querySelectorAll(".article").forEach(function(elem){elem.classList.add("hyphenate")});
    document.querySelectorAll("div.title").forEach(function(elem){elem.classList.add("donthyphenate")});
    Hyphenator.run();
  });
</script>

<article class="article">

  <header class="article-header">

  <div class="page-navigation">
    <ul>
      <!-- <li id="page-navigation-previous"><span><a href="">Previous</a></span></li> -->
      <li id="page-navigation-home"><span><a href="/projects/logics-2016/lecture-notes/">Contents</a></span></li>
      <!-- <li id="page-navigation-next"><span><a href="">Next</a></span></li> -->
    </ul>
  </div>

  <h1 class="article-title">Logics 2016 Lecture Notes Eight (Part III: 1)</h1>

  <p class="article-meta">
    
      <time datetime="2016-12-04T00:00:00+09:00" itemprop="datePublished">December, 2016</time>

      <br/>

      

      <span class="referral">

	
	<span class="revision">Version One, First Draft, Third Revision</span>
	

	<span class="repo-ref">logics-2016/lecture-notes:git-49a495382ba04d5d3f8fdf5655497314c1cd04d2</span>
	<span class="url-ref"><a href="http://sicss.org/projects/logics-2016/lecture-notes/Logics-2016-Lecture-Notes-Eight">http://sicss.org/projects/logics-2016/lecture-notes/Logics-2016-Lecture-Notes-Eight</a></span>
      </span>


  </p>

</header>

<div class="article-content">
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph preface">
<div class="title">Preamble</div>
<p>This article is part of the lecture notes series authored for Sicss Logics Seminar 2016. This
article covers Part III: <strong>1. Natural Deduction Style Proof Theory</strong>. This note is unfinished.</p>
</div>
	<script type="text/x-mathjax-config">
	MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
	  var TEXDEFS = MathJax.InputJax.TeX.Definitions;
	  TEXDEFS.delimiter["\\llbracket"] = "27E6";
	  TEXDEFS.delimiter["\\rrbracket"] = "27E7";
	});

	MathJax.Hub.Register.StartupHook("HTML-CSS Jax Ready",function () {
	  var HTMLCSS = MathJax.OutputJax["HTML-CSS"],
	      DELIMITERS = HTMLCSS.FONTDATA.DELIMITERS;

	  var GENERAL = "STIXGeneral",
	      SIZE1   = "STIXSizeOneSym",
	      SIZE2   = "STIXSizeTwoSym",
	      SIZE3   = "STIXSizeThreeSym",
	      SIZE4   = "STIXSizeFourSym";

	  if (HTMLCSS.fontInUse === "STIX") {
	    // left white square bracket
	    DELIMITERS[0x27E6] = {
	      dir: "V", HW: [[.93,GENERAL],[1.23,SIZE1],[1.845,SIZE2],[2.46,SIZE3],[3.075,SIZE4]],
	      stretch: {top:[0x2553,GENERAL], ext:[0x2551,GENERAL], bot:[0x2559,GENERAL]}
	    };
	    // right white square bracket
	    DELIMITERS[0x27E7] = {
	      dir: "V", HW: [[.93,GENERAL],[1.23,SIZE1],[1.845,SIZE2],[2.46,SIZE3],[3.075,SIZE4]],
	      stretch: {top:[0x2556,GENERAL], ext:[0x2551,GENERAL], bot:[0x255C,GENERAL]}
	    };
	  }
	});
	</script>
<div style="display:block">
$-$
\newcommand\judges{\vdash}
\newcommand\tuple[1]{\langle #1 \rangle}
\newcommand\intpr[1]{\llbracket #1 \rrbracket}
%\newcommand\intprx[1]{\llbracket #1 \rrbracket_{x_1,\dots,x_n}}
\newcommand\intprx[1]{\llbracket #1 \rrbracket_{x_{1\dots n}}}
\newcommand\intprxn[2]{\llbracket #2 \rrbracket_{x_1,\dots,x_{#1}}}
\newcommand\fun[2]{\lambda{#1}. #2}
\newcommand\comprh[2]{\{#1\;\;|\;\;#2\}}
\newcommand\qqquad{\quad\quad\quad}
\newcommand\rulesp{\quad\quad}
\newcommand\hyposp{\quad\;}
\newcommand\ensuremath[1]{#1}
\newcommand\infrn[3]{\ensuremath{\frac{#2}{#3}\;{#1}}}
\newcommand\infr[2]{\begin{gathered}\underline{\;#1\;} \\ {#2}\end{gathered}}
$-$
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-1-natural-deduction-style-proof-theory">Chapter 1. Natural Deduction Style Proof Theory</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="provable-relation">Provable Relation</h3>
<div class="paragraph">
<p>We call $ \Gamma \judges \phi $ a <strong>judgment</strong> where $\Gamma$ is a finite list of formulas and $\phi$
a formula. Of cause using this notation, we have a fixed first order theory in mind and all the
formulas are meant to be well formed in that particular theory. When we write down a judgment
$\Gamma \judges \phi$, we are claiming that $\phi$ is <strong>provable</strong> from $\Gamma$; thus here indeed, we
are regarding $\judges$ as a binary relation between the set of finite lists of formulas and the set
of formulas. We generally call the $\Gamma$, the list of formulas from which $\gamma$ is provable,
the <strong>context</strong> and $\phi$ the <strong>conclusion</strong>. And the exact definition of this <strong>provable relation</strong> is
the heart of the <em>proof theory</em> for first order logic. As commented in the introduction part of this
seminar, there exist a few different styles of proof theories for first order logic, and we are
going to introduce one of those, the <strong>natural deduction</strong> style and the inductive definition of the
provable relation in this particular style is given below.</p>
</div>
<div class="paragraph">
<p>$-$
\infrn{\textit{assum}}{}{\Gamma _1, \phi, \Gamma _2 \judges \phi} \\
\begin{gathered}
\infrn{\wedge\iota}{\Gamma\judges\phi \hyposp \Gamma\judges\psi}{\Gamma\judges\phi\wedge\psi} \\
%
\infrn{\vee\iota _1}{\Gamma\judges\phi}{\Gamma\judges\phi\vee\psi} \rulesp
\infrn{\vee\iota _2}{\Gamma\judges\psi}{\Gamma\judges\phi\vee\psi} \\
%
\infrn{\rightarrow\!\!\iota}{\Gamma,\phi\judges\psi}{\Gamma\judges\phi\rightarrow\psi} \\
%
\phantom{\infrn{\text{Phantom}}{\text{Phan-}}{\text{tom}}} \\
%
\infrn{\forall\iota}{\Gamma\judges\phi[x\mapsto y] \hyposp y \not\in fv(\Gamma) \cup fv(\phi) }{%
  \Gamma\judges\forall{x}\phi} \\
%
\infrn{\exists\iota}{\Gamma\judges\phi[x\mapsto t]}{\Gamma\judges\exists{x}\phi} \\
\end{gathered}
\qqquad
\begin{gathered}
\infrn{\wedge\epsilon _1}{\Gamma\judges\phi\wedge\psi}{\Gamma\judges\phi} \rulesp
\infrn{\wedge\epsilon _2}{\Gamma\judges\phi\wedge\psi}{\Gamma\judges\psi} \\
%
\infrn{\vee\epsilon}{%
  \Gamma\judges\phi\vee\psi \hyposp \Gamma,\phi\judges\gamma \hyposp \Gamma,\psi\judges\gamma }{%
  \Gamma\judges\gamma} \\
%
\infrn{\rightarrow\!\!\epsilon}{%
  \Gamma\judges\phi\rightarrow\psi \hyposp \Gamma\judges\phi}{\Gamma\judges\psi} \\
%
\infrn{\bot\epsilon _1}{\Gamma\judges\bot}{\Gamma\judges\phi} \rulesp
\infrn{\neg\neg _C}{\Gamma\judges\neg\neg\phi}{\Gamma\judges\phi} \\
%
\infrn{\forall\epsilon}{\Gamma\judges\forall{x}\phi}{\Gamma\judges\phi[x\mapsto t]} \\
%
\infrn{\exists\epsilon}{%
  \Gamma\judges\exists{x}\phi \hyposp \Gamma,\phi[x\mapsto y]\judges\psi
    \hyposp y\not\in fv(\Gamma) \cup fv(\phi) \cup fv(\psi)}{%
  \Gamma\judges\psi}
\end{gathered} \\
\infrn{\textit{refl} }{}{\Gamma\judges{t = t}} \rulesp
\infrn{\textit{sym}}{\Gamma\judges{s = t}}{\Gamma\judges{t = s}} \rulesp
\infrn{\textit{trans}}{\Gamma\judges{s = t} \hyposp \Gamma\judges{t = u}}{\Gamma\judges{s = u}}
$-$</p>
</div>
<div class="paragraph">
<p>Here, we actually are using notations that have not been introduced. Firstly, for a list of
formulas, we use a comma to denote concatenation both for the case of appending a list with an
element, and a list with another list. Thus $\Gamma, \phi$ should be understood as the new list,
obtained by appending $\phi$ as the last element to the list $\Gamma$; $\Gamma _1, \Gamma _2$ should
be understood as the new list, obtained by lining up the elements in $\Gamma _1$ and $\Gamma _2$
together, where those elements from $\Gamma _1$ comes first; and $\Gamma _1, \phi, \Gamma _2$ just
means $(\Gamma _1, \phi), \Gamma _2$. We also have not defined the function $fv$, the function
taking the set of free variables, for a list of formulas, though its definition is very obvious: we
just take the union of the results applying $fv$ on each of the elements in the list.</p>
</div>
<div class="paragraph">
<p>The definition itself is presented in the <em>reference rules</em> style for writing down inductive
definitions, which is also introduced in the introduction part of this seminar. Observe that a name
is given for each rule, but those names are abbreviated and here are the explanations. "<em>assum</em>" is
the abbreviation for <em>assumption</em>, since this rule allows one to regard a formula occurring in the
context (the assumptions) being provable. "<em>refl</em>", "<em>sym</em>", and "<em>trans</em>" are the abbreviations
respectively for "reflexivity", "symmetry", and "transitivity", since these rules depict those
properties of the equity relation. Each of the rest rule names contains a logical symbol and either
"$\iota$" or "$\epsilon$" (except for "$\neg\neg _ C$", which will be explained later.) Those are
the rules stipulating how a certain logical symbol could be <strong>introduced</strong> (those rules whose names
end in "$\iota$") or <strong>eliminated</strong> (those rules whose names end in "$\epsilon$") in the
conclusions. The rule $\neg\neg _ C$ could also be named $\bot\epsilon _ 2$, since recalling that
$\neg\phi$ is just a shorthand for writing $\phi\rightarrow\bot$, this rule stipulates how $\bot$
could be eliminated in another way. But yet including this rule in the definition of the provable
relation, we effectively make the formal system we are building to be a member in the class of
<em>classical logics</em>, instead of the class of <em>intuitionistic logics</em>, also this rule directly deals
with double negation. Thus we name it $\neg\neg _C$, where the "C" denotes "classical".</p>
</div>
<div class="paragraph">
<p>Recalling that writing down $\Gamma\judges\phi$ means that $\phi$ is provable from $\Gamma$, one
should feel easy to interpret these rules. For example the rule $\wedge\iota$ stipulates that <em>if
$\phi$ and $\psi$ are both provable from $\Gamma$, which is a list of assumptions, then
$\phi\wedge\psi$ is also provable from $\Gamma$, the same list of assumptions</em>; and since there is
no other introduction rule for $\wedge$, the "if" should actually have been "iff". If you take time
examining all the rules (which you should it right now!), all of them should be acceptable as
correct naturally. In fact, this collection of rules of proof is designed to be both <em>complete</em> (in
the sense that every valid formula is provable), and reflects the structure of ordinary mathematical
proofs as much as possible. This is also how the name of this proof style, "natural deduction",
comes.</p>
</div>
</div>
<div class="sect2">
<h3 id="proof">Proof</h3>
<div class="paragraph">
<p>We defined the provable relation in the last section: it is then natural to call a demonstration of
how $\Gamma\judges\phi$ is true the <strong>proof</strong> for $\Gamma\judges\phi$. Observe, that the definition of
the provable relation is given as an inductive definition. This means that a demonstration of
$\Gamma$ and $\phi$ respecting this relation is nothing other than the derivation tree for
$\Gamma\judges\phi$, which in turn means that a <em>proof</em> of $\Gamma\judges\phi$ is nothing other than
a derivation tree for $\Gamma\judges\phi$. Since a proof in the formal system we are defining here
is always a tree, we also sometime call a proof a <strong>proof tree</strong>. For example, here is a proof for
$\phi\wedge\neg\phi\judges\psi$:</p>
</div>
<div class="paragraph">
<p>$-$
\newcommand\P{\phi}
\newcommand\nP{\neg\P}
\newcommand\Q{\psi}
\begin{align*}
\infr{\infr{\infr{\P\wedge\nP\judges\P\wedge\nP}{\P\wedge\nP\judges\P} \hyposp
\infr{\P\wedge\nP\judges\P\wedge\nP}{\P\wedge\nP\judges\nP} \hyposp \text{(note that $\nP\equiv\P\rightarrow\bot$)}}{\P\wedge\nP\judges\bot}}{\P\wedge\nP\judges\Q}
\end{align*}
$-$</p>
</div>
</div>
<div class="sect2">
<h3 id="theorem">Theorem</h3>
<div class="paragraph">
<p>As discussed in the introduction part, the proof theory aspect of a general formal system consists
of a systematic method to name the <strong>theorems</strong> of that system. By definition, the set of theorems is
a subset of the language of the system, and we must be able to judge whether a formula is a theorem
by only looking at its syntactical structure. We also discussed that, giving the latter property,
the proof theory of a certain formal system can be effectively given in 2 parts, the set of axioms,
and the set of inference rules.</p>
</div>
<div class="paragraph">
<p>Talking about the natural deduction style proof theory for the first order logic, the scenario is
still the same. We defined a binary relation, the provable relation $\judges$, but that is not a
direct definition for the set of theorems; thereby the definition of the provable relation itself
does not constitute a proof theory. Moreover, just in the same spirit that the language of a first
order theory is parameterized by the sets of prediction &amp; function symbols, the proof theory of a
first order theory is parameterized by the set of non-logical axioms, which we will denote with
$\mathfrak{X}$.</p>
</div>
<div class="paragraph">
<p>Nevertheless, with the provable relation defined in the natural deduction style, the set of theorems
of a first order theory could then be easily stated. We hereby define that <em>a formula $\phi$ of a
first order theory whose set of non-logical axioms being $\mathfrak{X}$ is a theorem of that theory
if there exists a finite list $\Gamma$ of elements in $\mathfrak{X}$ such that $\Gamma\judges\phi$.</em>
Since we are not dealing with proofs of infinite size, it introduces no ambiguity to use
$A\judges\phi$ where $A$ is a general set of formulas to denote <em>there exists a finite list $\Gamma$
of elements in $A$ such that $\Gamma\judges\phi$.</em> This notation will be used frequently in the
discussion on completeness theorem and should not be understood as "$\phi$ is provable from the
(potentially infinite) list consists of all the elements in $A$". With this notation, we could
simplify the definition of the set of formulas of a first order theory whose set of non-logical
axioms being $\mathfrak{X}$ greatly to a concise and neat form: $\{\phi\in\mathbf{Form} \;|\;
\mathfrak{X}\judges\phi\}$. This is also the proof theory we pick for <strong>Pred<sup>1</sup></strong></p>
</div>
<div class="paragraph">
<p><strong>Exercise 3.1.1:</strong> Prove that exchanging the order of formulas in the context doesn&#8217;t change the
provability of a formula, i.e. <em>for any formula $\phi _1$, $\phi _2$, and $\psi$, and any context of
formulas $\Gamma _1$ and $\Gamma _2$, $\Gamma _1, \phi _1, \phi _2, \Gamma _2 \judges \psi$ iff
$\Gamma _1, \phi _2, \phi _1, \Gamma _2 \judges \psi$.</em></p>
</div>
<div class="paragraph">
<p><strong>Exercise 3.1.2:</strong> Prove that adding a new formula to the context doesn&#8217;t decrease the provability of
a formula, i.e. <em>for any formula $\phi$, $\psi$, and any context of formulas $\Gamma$,
$\Gamma,\phi\judges\psi$ if $\Gamma\judges\psi$.</em> This kind of manipulations to context (adding
useless assumptions) is often called "weakening".</p>
</div>
<div class="paragraph">
<p><strong>Exercise 3.1.3:</strong> Prove that removing a duplicated formula in the context doesn&#8217;t change the
provability of a formula, i.e. <em>for any formula $\phi _1$, $\phi _2$, $\psi$, and for any context of
formulas $\Gamma _1$, $\Gamma _2$, and $\Gamma _3$, $\Gamma _1, \phi _1, \Gamma _2, \phi _2, \Gamma
_3 \judges \psi$ iff $\Gamma _1, \phi _1, \Gamma _2, \Gamma _3 \judges \psi$.</em> This kind of
manipulations to context (removing duplicated formulas) is often called "contraction".</p>
</div>
<div class="paragraph">
<p><strong>Exercise 3.1.4:</strong> Prove that removing a formula from the context that is implied by the rest of the
context doesn&#8217;t decrease the provability of a formula, i.e. <em>for any formula $\phi$ and $\psi$, and
for any context $\Gamma _1$ and $\Gamma _2$, $\Gamma _1, \Gamma _2 \judges \psi$ if $\Gamma _1,
\phi, \Gamma _2 \judges \psi$ and $\Gamma\judges\phi$.</em></p>
</div>
<div class="paragraph">
<p>With the results in exercises 3.1.1 to 3.1.4, we can greatly simplify the proof tree by omitting all
the contexts from it excepts those at the leaves (those rule applications without hypothesis). This
is okay since we can recovery this information (not exact but good enough) by basically taking the
combination of all the contexts at the leaves, called the global context, to be the context for the
conclusion at every node. The global context obtained by this method is not essential enough since,
revisit the definition of the provable relation and observe that the context does not always remain
unchanged below and under the bar of the rules. Therefore some special treatments are needed for
those rules where the contexts does change (namely, the rules $\vee\epsilon$,
$\rightarrow\!\!\iota$, and $\exists\epsilon$). Although, interestingly, the context always becomes
shorter in those rules and never grows longer. This means that if we keep track of which formulas
are removed from the context from leaves to root, we can form the essential global context
exactly. The operation of excluding a formula from the global context is called <strong>discharging</strong>, and a
formula being discharged is usually denoted with a bracket.</p>
</div>
<div class="paragraph">
<p>(add an example of simplified proof trees)</p>
</div>
<div class="paragraph">
<p><strong>Exercise 3.1.5:</strong> Prove the "proof by contradiction" technique: <em>for any formula $\phi$ and any
context $\Gamma$, $\Gamma\judges\phi$ if $\Gamma, \neg\phi\judges\bot$.</em></p>
</div>
</div>
</div>
</div>
</div>




</article>



    </main>

    <footer>

  <div class="hr"></div>

  <div class="copyright-notice">

    <p>
      Copyright &copy; 2016 Sicss Society. <br/>
      All rights reserved.
    </p>

    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> <br/>
      This work is licensed under a <br/>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
	Creative Commons Attribution-NonCommercial-ShareAlike 4.0
	International License</a>.
    </p>

  </div>

</footer>



  </body>

</html>

